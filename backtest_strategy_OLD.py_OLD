# backtest_strategy.py - Backtesting using the unified strategy logic
import sqlite3
import pandas as pd
from datetime import datetime, timedelta
from strategy_core import HighVolumeBreakoutStrategy
from config import *
import traceback
import pandas as pd

import matplotlib.pyplot as plt

class Backtester:
    def __init__(self):
        self.conn = sqlite3.connect(DB_FILE)
        self.strategy = HighVolumeBreakoutStrategy()
    
    def load_symbol_data(self, symbol, start_date=None, end_date=None):
        """Load data for a specific symbol from the database"""
        query = f"SELECT datetime, open, high, low, close, volume FROM stock_data WHERE symbol = ?"
        params = [symbol]
        
        if start_date and end_date:
            query += " AND datetime >= ? AND datetime <= ?"
            params.extend([start_date, end_date])
        
        query += " ORDER BY datetime ASC"
        
        df = pd.read_sql_query(query, self.conn, params=params, parse_dates=['datetime'])
        
        if not df.empty:
            # Add derived columns
            df['value_cr'] = (df['close'] * df['volume']) / 1e7  # Value in Crores
            df['vol_sma_200'] = df['volume'].rolling(200).mean()
            df['hour'] = df['datetime'].dt.hour
            df['minute'] = df['datetime'].dt.minute
            
        return df
    
    def run_backtest(self, symbols=None, start_date=None, end_date=None):
        """Run backtest on multiple symbols using the unified strategy logic"""
        print("Starting backtest with unified strategy...")
        
        # Get symbols if not provided
        if symbols is None:
            query = "SELECT DISTINCT symbol FROM stock_data"
            df_symbols = pd.read_sql_query(query, self.conn)
            symbols = df_symbols['symbol'].tolist()
        
        all_trades = []
        
        # Run backtest for each symbol
        for symbol in symbols:
            try:
                trades = self.backtest_symbol(symbol, start_date, end_date)
                if trades:
                    all_trades.extend(trades)
                    print(f"Found {len(trades)} trades for {symbol}")
            except Exception as e:
                print(f"Error backtesting {symbol}: {e}")
                traceback.print_exc()
        
        # Save results
        if all_trades:
            df_trades = pd.DataFrame(all_trades)
            df_trades.to_csv(BACKTEST_RESULTS_CSV, index=False)
            print(f"Backtest complete! Results saved to {BACKTEST_RESULTS_CSV}")
            
            # Generate summary
            self.generate_summary(df_trades)
            
            return df_trades
        else:
            print("No trades found")
            return pd.DataFrame()
    
    def backtest_symbol(self, symbol, start_date=None, end_date=None):
        """Backtest a single symbol using the unified strategy logic"""
        print(f"Backtesting {symbol}...")
        
        # Load data
        df = self.load_symbol_data(symbol, start_date, end_date)
        
        if df is None or df.empty:
            print(f"No data for {symbol}")
            return []
        
        trades = []
        current_day = None
        daily_trades = 0
        
        # Backtest loop - uses the same logic as real-time
        for i in range(200, len(df)):  # Start after 200-bar SMA is available
            current_time = df.iloc[i]['datetime'].strftime('%H:%M')
            current_date = df.iloc[i]['datetime'].date()
            
            # Reset daily trade count at start of new day
            if current_date != current_day:
                current_day = current_date
                daily_trades = 0
            
            # Skip if daily trade limit reached
            if daily_trades >= MAX_DAILY_TRADES:
                continue
            
            # --- Use the unified strategy logic ---
            setup = self.strategy.analyze_setup(df, i)
            
            if setup is None:
                continue
            
            # --- EXECUTION PHASE ---
            # Simulate trade execution using the unified exit logic
            exit_price, exit_time, exit_reason, pnl = self.strategy.simulate_exit(df, i, setup)
            
            # Record trade
            if exit_price is not None:
                trade = {
                    'Symbol': symbol,
                    'EntryTime': df.iloc[i]['datetime'],
                    'ExitTime': exit_time,
                    'Direction': setup['direction'],
                    'EntryPrice': setup['entry_price'],
                    'ExitPrice': exit_price,
                    'PositionSize': setup['position_size'],
                    'StopLoss': setup['stop_loss'],
                    'Target': setup['target'],
                    'PnL': pnl,
                    'ExitReason': exit_reason,
                    'VolumeRatio': setup['volume_ratio'],
                    'ValueTraded': setup['value_traded'],
                    'SupportLevels': str(setup['support_levels']),
                    'ResistanceLevels': str(setup['resistance_levels']),
                    'InConsolidation': setup['in_consolidation'],
                    'BreakingS_R': setup['breaking_s_r']
                }
                trades.append(trade)
                daily_trades += 1
        
        return trades
    
    def generate_summary(self, df_trades):
        """Generate backtest summary"""
        if df_trades.empty:
            return
        
        # Overall performance
        total_trades = len(df_trades)
        winning_trades = len(df_trades[df_trades['PnL'] > 0])
        losing_trades = len(df_trades[df_trades['PnL'] <= 0])
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        total_pnl = df_trades['PnL'].sum()
        avg_pnl = df_trades['PnL'].mean()
        max_win = df_trades['PnL'].max()
        max_loss = df_trades['PnL'].min()
        
        # Performance by symbol
        symbol_performance = df_trades.groupby('Symbol').agg({
            'PnL': ['count', 'sum', 'mean'],
            'Direction': lambda x: (x == 'Long').sum(),
            'ExitReason': lambda x: (x == 'TARGET').sum()
        }).round(2)
        
        symbol_performance.columns = ['_'.join(col).strip() for col in symbol_performance.columns]
        symbol_performance = symbol_performance.reset_index()
        symbol_performance.columns = ['Symbol', 'Total_Trades', 'Total_PnL', 'Avg_PnL', 'Long_Trades', 'Target_Hits']
        symbol_performance['Win_Rate'] = df_trades.groupby('Symbol')['PnL'].apply(lambda x: (x > 0).mean()).round(2).values
        
        # Save summary
        summary_data = {
            'Metric': ['Total_Trades', 'Winning_Trades', 'Losing_Trades', 'Win_Rate', 
                      'Total_PnL', 'Avg_PnL', 'Max_Win', 'Max_Loss'],
            'Value': [total_trades, winning_trades, losing_trades, f"{win_rate:.2%}", 
                     total_pnl, avg_pnl, max_win, max_loss]
        }
        
        df_summary = pd.DataFrame(summary_data)
        df_summary.to_csv(BACKTEST_SUMMARY_CSV, index=False)
        symbol_performance.to_csv('symbol_performance.csv', index=False)
        
        print(f"Backtest summary saved to {BACKTEST_SUMMARY_CSV}")
        
        # Create visualizations
        self.create_visualizations(df_trades, symbol_performance)
        
        # Print summary
        print("\n" + "="*60)
        print("BACKTEST SUMMARY")
        print("="*60)
        print(f"Total Trades: {total_trades}")
        print(f"Win Rate: {win_rate:.2%}")
        print(f"Total PnL: ₹{total_pnl:,.2f}")
        print(f"Average PnL: ₹{avg_pnl:,.2f}")
        print(f"Max Win: ₹{max_win:,.2f}")
        print(f"Max Loss: ₹{max_loss:,.2f}")
    
    def create_visualizations(self, df_trades, symbol_performance):
        """Create backtest visualizations"""
        # Set style
        plt.style.use('default')
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        fig.suptitle('High Volume Breakout Strategy Backtest Results', fontsize=16, fontweight='bold')
        
        # 1. PnL Distribution
        axes[0, 0].hist(df_trades['PnL'], bins=50, alpha=0.7, color='skyblue', edgecolor='black')
        axes[0, 0].axvline(df_trades['PnL'].mean(), color='red', linestyle='--', label=f'Mean: ₹{df_trades["PnL"].mean():,.2f}')
        axes[0, 0].set_xlabel('PnL (₹)')
        axes[0, 0].set_ylabel('Frequency')
        axes[0, 0].set_title('PnL Distribution')
        axes[0, 0].legend()
        
        # 2. Cumulative PnL
        df_trades_sorted = df_trades.sort_values('EntryTime')
        df_trades_sorted['Cumulative_PnL'] = df_trades_sorted['PnL'].cumsum()
        axes[0, 1].plot(df_trades_sorted['EntryTime'], df_trades_sorted['Cumulative_PnL'], color='green')
        axes[0, 1].set_xlabel('Date')
        axes[0, 1].set_ylabel('Cumulative PnL (₹)')
        axes[0, 1].set_title('Cumulative PnL Over Time')
        axes[0, 1].grid(True, alpha=0.3)
        
        # 3. Win Rate by Symbol
        top_symbols = symbol_performance.head(10)
        colors = ['green' if wr > 0.5 else 'red' for wr in top_symbols['Win_Rate']]
        axes[1, 0].barh(top_symbols['Symbol'], top_symbols['Win_Rate'], color=colors)
        axes[1, 0].set_xlabel('Win Rate')
        axes[1, 0].set_title('Win Rate by Symbol (Top 10)')
        axes[1, 0].set_xlim(0, 1)
        
        # 4. PnL by Symbol
        pnl_by_symbol = top_symbols.sort_values('Total_PnL', ascending=False)
        colors = ['green' if pnl > 0 else 'red' for pnl in pnl_by_symbol['Total_PnL']]
        axes[1, 1].bar(pnl_by_symbol['Symbol'], pnl_by_symbol['Total_PnL'], color=colors)
        axes[1, 1].set_xlabel('Symbol')
        axes[1, 1].set_ylabel('Total PnL (₹)')
        axes[1, 1].set_title('Total PnL by Symbol (Top 10)')
        plt.setp(axes[1, 1].xaxis.get_majorticklabels(), rotation=45)
        
        plt.tight_layout()
        plt.savefig(os.path.join(BACKTEST_CHARTS_DIR, 'backtest_results.png'), dpi=300, bbox_inches='tight')
        plt.close()

# Run the backtest
if __name__ == "__main__":
    # Define date range (optional)
    start_date = "2025-08-12"
    end_date = "2025-12-31"
    
    # Define specific symbols to backtest (optional)
    # symbols = ["RELIANCE", "INFY", "TCS", "HDFCBANK"]
    symbols = None  # Use all symbols in database
    
    # Run backtest
    backtester = Backtester()
    results = backtester.run_backtest(symbols=symbols, start_date=start_date, end_date=end_date)